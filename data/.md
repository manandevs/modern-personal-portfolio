
2. Fundamentals of C Language
2.1 Keywords and Identifiers
code
Code
*   **2.1.1 C Keywords**: Reserved words with special meaning.
    *   2.1.1.1 List of C89/C90 keywords (e.g., `int`, `if`, `while`, `return`)
    *   2.1.1.2 New keywords in C99 (e.g., `_Bool`, `_Complex`, `inline`, `restrict`)
    *   2.1.1.3 New keywords in C11 (e.g., `_Alignas`, `_Alignof`, `_Atomic`, `_Generic`, `_Noreturn`, `_Static_assert`, `_Thread_local`)
    *   2.1.1.4 New keywords in C23 (e.g., `true`, `false`, `static_assert`, `typeof`)
*   **2.1.2 Identifiers**: Naming conventions for variables, functions, etc.
    *   2.1.2.1 Rules for creating valid identifiers
    *   2.1.2.2 Case sensitivity
    *   2.1.2.3 Best practices for identifier naming (readability, consistency)
2.2 Variables and Constants
code
Code
*   **2.2.1 Variables**: Memory locations to store data.
    *   2.2.1.1 Declaration of variables
    *   2.2.1.2 Initialization of variables
    *   2.2.1.3 Lvalues and Rvalues
    *   2.2.1.4 Variable scope (local, global)
    *   2.2.1.5 Variable lifetime
*   **2.2.2 Constants**: Fixed values that cannot change during execution.
    *   2.2.2.1 Literal constants (integer, floating-point, character, string)
        *   2.2.2.1.1 Integer literals (decimal, octal, hexadecimal)
        *   2.2.2.1.2 Suffixes for integer literals (L, U, LL, ULL)
        *   2.2.2.1.3 Floating-point literals (f, F, l, L)
        *   2.2.2.1.4 Character literals (single quotes, escape sequences)
        *   2.2.2.1.5 String literals (double quotes)
    *   2.2.2.2 `const` keyword: creating symbolic constants
        *   2.2.2.2.1 `const` with variables
        *   2.2.2.2.2 `const` with pointers (pointer to const, const pointer, const pointer to const)
    *   2.2.2.3 `#define` preprocessor directive: macro constants
        *   2.2.2.3.1 Simple macro definitions
        *   2.2.2.3.2 Advantages and disadvantages of `#define` vs. `const`
    *   2.2.2.4 `enum` (Enumeration): creating a set of named integer constants
2.3 Data Types
code
Code
*   **2.3.1 Primitive Data Types**: Basic building blocks.
    *   2.3.1.1 Integer types
        *   2.3.1.1.1 `char`: typically 1 byte, stores characters or small integers
        *   2.3.1.1.2 `signed char`, `unsigned char`
        *   2.3.1.1.3 `short int` (or `short`): usually 2 bytes
        *   2.3.1.1.4 `unsigned short int`
        *   2.3.1.1.5 `int`: typically 2 or 4 bytes, common integer type
        *   2.3.1.1.6 `unsigned int`
        *   2.3.1.1.7 `long int` (or `long`): usually 4 or 8 bytes
        *   2.3.1.1.8 `unsigned long int`
        *   2.3.1.1.9 `long long int` (or `long long`): C99, at least 8 bytes
        *   2.3.1.1.10 `unsigned long long int`
    *   2.3.1.2 Floating-point types
        *   2.3.1.2.1 `float`: single-precision floating-point (usually 4 bytes)
        *   2.3.1.2.2 `double`: double-precision floating-point (usually 8 bytes)
        *   2.3.1.2.3 `long double`: extended precision floating-point (usually 10 or 12 bytes)
    *   2.3.1.3 `_Bool` (Boolean): C99, stores true/false (0 or 1)
        *   2.3.1.3.1 `stdbool.h` header and `bool`, `true`, `false` macros
    *   2.3.1.4 `void`: absence of type (e.g., for functions returning nothing, generic pointers)
*   **2.3.2 Derived Data Types**: Built from primitive types.
    *   2.3.2.1 Arrays
    *   2.3.2.2 Pointers
    *   2.3.2.3 Structures
    *   2.3.2.4 Unions
    *   2.3.2.5 Functions
*   **2.3.3 Type Modifiers**: Changing the meaning of basic types.
    *   2.3.3.1 `signed`
    *   2.3.3.2 `unsigned`
    *   2.3.3.3 `short`
    *   2.3.3.4 `long`
*   **2.3.4 Type Conversion (Type Casting)**: Changing one data type to another.
    *   2.3.4.1 Implicit type conversion (coercion)
        *   2.3.4.1.1 Type promotion rules
        *   2.3.4.1.2 Usual arithmetic conversions
    *   2.3.4.2 Explicit type conversion (casting operator)
        *   2.3.4.2.1 Syntax `(type)expression`
        *   2.3.4.2.2 Use cases for explicit casting
        *   2.3.4.2.3 Potential data loss during casting
2.4 Input and Output (I/O)
code
Code
*   **2.4.1 Standard I/O Library (`stdio.h`)**: The core I/O functions.
    *   2.4.1.1 `printf()`: formatted output to console.
        *   2.4.1.1.1 Format specifiers (e.g., `%d`, `%f`, `%c`, `%s`, `%x`)
        *   2.4.1.1.2 Escape sequences (e.g., `\n`, `\t`, `\b`, `\\`, `\"`)
        *   2.4.1.1.3 Field width and precision specifiers (`%5d`, `%.2f`)
        *   2.4.1.1.4 Flags (`+`, `-`, `0`, `#`, ` `)
    *   2.4.1.2 `scanf()`: formatted input from console.
        *   2.4.1.2.1 Format specifiers (matching `printf`'s)
        *   2.4.1.2.2 Address-of operator (`&`) for variables
        *   2.4.1.2.3 Return value of `scanf()` (number of items successfully read)
        *   2.4.1.2.4 Handling input buffer issues (e.g., `getchar()`, `fflush(stdin)` - though `fflush(stdin)` is non-standard)
    *   2.4.1.3 `getchar()` and `putchar()`: character-based I/O.
        *   2.4.1.3.1 Reading single characters
        *   2.4.1.3.2 Writing single characters
    *   2.4.1.4 `gets()` and `puts()`: string-based I/O (Note: `gets()` is unsafe and deprecated).
        *   2.4.1.4.1 Reading strings (dangers of buffer overflow with `gets()`)
        *   2.4.1.4.2 Writing strings
    *   2.4.1.5 `fgets()` and `fputs()`: safer string I/O.
        *   2.4.1.5.1 Reading strings with size limit
        *   2.4.1.5.2 Writing strings (often used for file I/O but can be used with `stdin`/`stdout`)
    *   2.4.1.6 `getch()` and `getche()`: non-standard character input (often found in `conio.h` for DOS/Windows).
*   **2.4.2 Standard Streams**: Predefined I/O channels.
    *   2.4.2.1 `stdin`: Standard input (keyboard)
    *   2.4.2.2 `stdout`: Standard output (console)
    *   2.4.2.3 `stderr`: Standard error (console, for error messages)
3. Operators in C
3.1 Arithmetic Operators
code
Code
*   **3.1.1 Basic Arithmetic**:
    *   3.1.1.1 Addition (`+`)
    *   3.1.1.2 Subtraction (`-`)
    *   3.1.1.3 Multiplication (`*`)
    *   3.1.1.4 Division (`/`): Integer division vs. floating-point division
    *   3.1.1.5 Modulo (`%`): Remainder operator (only for integers)
*   **3.1.2 Unary Arithmetic**:
    *   3.1.2.1 Unary Plus (`+`)
    *   3.1.2.2 Unary Minus (`-`)
3.2 Relational Operators
code
Code
*   **3.2.1 Comparison**: Used to compare two operands.
    *   3.2.1.1 Equal to (`==`)
    *   3.2.1.2 Not equal to (`!=`)
    *   3.2.1.3 Greater than (`>`)
    *   3.2.1.4 Less than (`<`)
    *   3.2.1.5 Greater than or equal to (`>=`)
    *   3.2.1.6 Less than or equal to (`<=`)
*   **3.2.2 Return Value**: Produce 0 (false) or 1 (true)
3.3 Logical Operators
code
Code
*   **3.3.1 Boolean Logic**: Combine or negate relational expressions.
    *   3.3.1.1 Logical AND (`&&`)
        *   3.3.1.1.1 Short-circuit evaluation of `&&`
    *   3.3.1.2 Logical OR (`||`)
        *   3.3.1.2.1 Short-circuit evaluation of `||`
    *   3.3.1.3 Logical NOT (`!`)
*   **3.3.2 Truth Tables**: Understanding operator behavior.
*   **3.3.3 Operator Precedence and Associativity**
3.4 Assignment Operators
code
Code
*   **3.4.1 Simple Assignment**:
    *   3.4.1.1 Assignment operator (`=`)
*   **3.4.2 Compound Assignment**: Shorthand for arithmetic-assignment.
    *   3.4.2.1 `+=` (add and assign)
    *   3.4.2.2 `-=` (subtract and assign)
    *   3.4.2.3 `*=` (multiply and assign)
    *   3.4.2.4 `/=` (divide and assign)
    *   3.4.2.5 `%=` (modulo and assign)
    *   3.4.2.6 `<<=` (left shift and assign)
    *   3.4.2.7 `>>=` (right shift and assign)
    *   3.4.2.8 `&=` (bitwise AND and assign)
    *   3.4.2.9 `|=` (bitwise OR and assign)
    *   3.4.2.10 `^=` (bitwise XOR and assign)
3.5 Increment and Decrement Operators
code
Code
*   **3.5.1 Increment**: Increasing a variable's value by 1.
    *   3.5.1.1 Post-increment (`++` after variable): value used then incremented
    *   3.5.1.2 Pre-increment (`++` before variable): value incremented then used
*   **3.5.2 Decrement**: Decreasing a variable's value by 1.
    *   3.5.2.1 Post-decrement (`--` after variable): value used then decremented
    *   3.5.2.2 Pre-decrement (`--` before variable): value decremented then used
*   **3.5.3 Side Effects**: Understanding when the value changes.
3.6 Bitwise Operators
code
Code
*   **3.6.1 Bit-level Manipulation**: Operate on individual bits.
    *   3.6.1.1 Bitwise AND (`&`)
    *   3.6.1.2 Bitwise OR (`|`)
    *   3.6.1.3 Bitwise XOR (`^`)
    *   3.6.1.4 Bitwise NOT (`~`) (one's complement)
    *   3.6.1.5 Left Shift (`<<`)
    *   3.6.1.6 Right Shift (`>>`)
*   **3.6.2 Applications**:
    *   3.6.2.1 Setting, clearing, toggling specific bits
    *   3.6.2.2 Checking bit status
    *   3.6.2.3 Multiplication/division by powers of 2
    *   3.6.2.4 Masking operations
3.7 Conditional (Ternary) Operator
code
Code
*   **3.7.1 Syntax**: `condition ? expression_if_true : expression_if_false`
*   **3.7.2 Usage**: Shorthand for simple `if-else` statements.
3.8 Special Operators
code
Code
*   **3.8.1 `sizeof` Operator**: Determines the size of a type or variable in bytes.
    *   3.8.1.1 `sizeof(type)`
    *   3.8.1.2 `sizeof(expression)`
    *   3.8.1.3 Usage with arrays and structures
*   **3.8.2 Comma Operator (`,`)**: Evaluates expressions from left to right, returns the value of the rightmost expression.
    *   3.8.2.1 Usage in `for` loops
    *   3.8.2.2 Understanding its low precedence
*   **3.8.3 Address-of Operator (`&`)**: Returns the memory address of a variable.
    *   3.8.3.1 Used with `scanf()`
    *   3.8.3.2 Essential for pointers
*   **3.8.4 Dereference Operator (`*`)**: Accesses the value at a memory address (pointer).
    *   3.8.4.1 Used to retrieve value pointed to by a pointer
3.9 Operator Precedence and Associativity
code
Code
*   **3.9.1 Precedence Rules**: Order of evaluation for different operators.
*   **3.9.2 Associativity Rules**: Order of evaluation for operators with the same precedence.
*   **3.9.3 Using Parentheses**: Overriding default precedence.
4. Control Statements
4.1 Decision Making (Conditional Statements)
code
Code
*   **4.1.1 `if` statement**: Executes a block of code if a condition is true.
    *   4.1.1.1 Syntax of `if`
    *   4.1.1.2 Importance of curly braces for single vs. multiple statements
*   **4.1.2 `if-else` statement**: Executes one block if true, another if false.
    *   4.1.2.1 Syntax of `if-else`
    *   4.1.2.2 Practical examples
*   **4.1.3 `nested if` statement**: `if` or `if-else` inside another `if` or `if-else`.
    *   4.1.3.1 How to structure nested conditions
    *   4.1.3.2 Avoiding excessive nesting (readability issues)
*   **4.1.4 `else-if` ladder (if-else if-else)**: Chain of conditions.
    *   4.1.4.1 Evaluating conditions sequentially
    *   4.1.4.2 The final `else` (optional)
    *   4.1.4.3 Performance considerations with long ladders
*   **4.1.5 `switch` statement**: Multi-way branch based on an integer expression.
    *   4.1.5.1 Syntax of `switch`, `case`, `default`, `break`
    *   4.1.5.2 Rules for `switch` expression and `case` labels
    *   4.1.5.3 The importance of `break` (fall-through behavior)
    *   4.1.5.4 When to use `switch` vs. `else-if` ladder
    *   4.1.5.5 Nested `switch` statements
4.2 Looping (Iterative Statements)
code
Code
*   **4.2.1 `for` loop**: Executes a block of code repeatedly for a fixed number of times or until a condition is met.
    *   4.2.1.1 Initialization, condition, increment/decrement parts
    *   4.2.1.2 Infinite `for` loops
    *   4.2.1.3 Omitting parts of the `for` loop
    *   4.2.1.4 Nested `for` loops
*   **4.2.2 `while` loop**: Executes a block of code as long as a condition is true (entry-controlled).
    *   4.2.2.1 Syntax of `while`
    *   4.2.2.2 Importance of updating the condition variable
    *   4.2.2.3 Infinite `while` loops
*   **4.2.3 `do-while` loop**: Executes a block of code at least once, then repeats as long as a condition is true (exit-controlled).
    *   4.2.3.1 Syntax of `do-while`
    *   4.2.3.2 When to use `do-while`
*   **4.2.4 Loop Selection**: Choosing the appropriate loop for the task.
4.3 Jump Statements
code
Code
*   **4.3.1 `break` statement**: Terminates the innermost loop or `switch` statement.
    *   4.3.1.1 Usage in `for`, `while`, `do-while` loops
    *   4.3.1.2 Usage in `switch` cases
    *   4.3.1.3 Breaking out of nested loops (requires more advanced techniques or `goto`)
*   **4.3.2 `continue` statement**: Skips the rest of the current iteration and proceeds to the next iteration of the loop.
    *   4.3.2.1 Usage in `for`, `while`, `do-while` loops
    *   4.3.2.2 Difference between `break` and `continue`
*   **4.3.3 `goto` statement**: Unconditional jump to a labeled statement.
    *   4.3.3.1 Syntax: `goto label;` and `label:`
    *   4.3.3.2 Best practices: generally discouraged due to creating "spaghetti code"
    *   4.3.3.3 Limited legitimate uses (e.g., breaking out of deeply nested loops, error handling in some contexts)
*   **4.3.4 `return` statement**: Terminates a function and returns control to the calling function.
    *   4.3.4.1 Returning a value (if function has a non-void return type)
    *   4.3.4.2 `return;` in `void` functions
5. Functions
5.1 Function Basics
code
Code
*   **5.1.1 What are Functions?**: Reusable blocks of code.
    *   5.1.1.1 Purpose of functions (modularity, reusability, abstraction)
*   **5.1.2 Function Declaration (Prototype)**: Informs the compiler about a function before its definition.
    *   5.1.2.1 Syntax: `return_type function_name(parameter_list);`
    *   5.1.2.2 Importance for compiler (type checking)
    *   5.1.2.3 Placement of prototypes (usually at the top of the file or in header files)
*   **5.1.3 Function Definition**: The actual implementation of the function.
    *   5.1.3.1 Syntax: `return_type function_name(parameter_list) { ... }`
    *   5.1.3.2 Function body
*   **5.1.4 Function Call**: Executing a function.
    *   5.1.4.1 Passing arguments
    *   5.1.4.2 Receiving return values
*   **5.1.5 `main()` Function**: The entry point of every C program.
    *   5.1.5.1 Return type `int`
    *   5.1.5.2 `return 0;` for successful execution
    *   5.1.5.3 Variants: `int main(void)`, `int main(int argc, char *argv[])`
5.2 Function Arguments
code
Code
*   **5.2.1 Call by Value**: Passing a copy of the argument's value.
    *   5.2.1.1 Original variable remains unchanged
    *   5.2.1.2 When to use call by value
*   **5.2.2 Call by Reference**: Passing the memory address of the argument.
    *   5.2.2.1 Using pointers to modify original variables
    *   5.2.2.2 When to use call by reference
    *   5.2.2.3 Example: Swapping two numbers using call by reference
5.3 Recursion
code
Code
*   **5.3.1 What is Recursion?**: A function calling itself.
    *   5.3.1.1 Base case: condition to stop recursion
    *   5.3.1.2 Recursive step: calling itself with a modified input
*   **5.3.2 Examples of Recursion**:
    *   5.3.2.1 Factorial calculation
    *   5.3.2.2 Fibonacci series
    *   5.3.2.3 Tower of Hanoi
*   **5.3.3 Recursion vs. Iteration**:
    *   5.3.3.1 Advantages and disadvantages of each
    *   5.3.3.2 Stack overflow issues with deep recursion
    *   5.3.3.3 Tail recursion (and potential compiler optimizations)
5.4 Storage Classes
code
Code
*   **5.4.1 Purpose of Storage Classes**: Define scope, lifetime, and linkage of variables.
*   **5.4.2 `auto` (Automatic)**: Default for local variables.
    *   5.4.2.1 Scope: local to the block
    *   5.4.2.2 Lifetime: exists only while the block is active
    *   5.4.2.3 Initialization: garbage value if not explicitly initialized
*   **5.4.3 `extern` (External)**: Declares a variable or function defined in another file or later in the same file.
    *   5.4.3.1 Linkage: external
    *   5.4.3.2 Purpose: sharing variables/functions across multiple source files
*   **5.4.4 `static`**: Modifies scope or lifetime.
    *   5.4.4.1 `static` local variables:
        *   5.4.4.1.1 Scope: local to the block
        *   5.4.4.1.2 Lifetime: persists for the entire program duration
        *   5.4.4.1.3 Initialization: initialized only once to 0 by default
    *   5.4.4.2 `static` global variables/functions:
        *   5.4.4.2.1 Scope: file scope
        *   5.4.4.2.2 Linkage: internal (visible only within the file)
        *   5.4.4.2.3 Purpose: Hiding implementation details
*   **5.4.5 `register`**: Suggests to the compiler to store variable in CPU register for faster access (compiler often ignores this hint).
    *   5.4.5.1 Cannot take the address of a `register` variable
    *   5.4.5.2 Limited practical use in modern compilers
5.5 Scope and Lifetime of Variables
code
Code
*   **5.5.1 Scope**: Region of the program where a variable is visible.
    *   5.5.1.1 Block scope (local variables)
    *   5.5.1.2 Function scope (labels in `goto`)
    *   5.5.1.3 File scope (global variables, static global variables)
    *   5.5.1.4 Prototype scope (parameters in function prototypes)
*   **5.5.2 Lifetime**: Duration for which a variable exists in memory.
    *   5.5.2.1 Static lifetime (global, static variables)
    *   5.5.2.2 Automatic lifetime (local variables)
    *   5.5.2.3 Dynamic lifetime (memory allocated with `malloc`, `calloc`)
6. Arrays
6.1 One-dimensional Arrays
code
Code
*   **6.1.1 What are Arrays?**: Collection of elements of the same data type.
    *   6.1.1.1 Stored in contiguous memory locations
*   **6.1.2 Declaration of One-dimensional Arrays**:
    *   6.1.2.1 Syntax: `data_type array_name[size];`
    *   6.1.2.2 Array size must be a constant expression (or a Variable Length Array in C99)
*   **6.1.3 Initialization of One-dimensional Arrays**:
    *   6.1.3.1 During declaration (e.g., `{10, 20, 30}`)
    *   6.1.3.2 Partial initialization
    *   6.1.3.3 Omitting size during initialization
    *   6.1.3.4 Initializing all elements to zero
*   **6.1.4 Accessing Array Elements**:
    *   6.1.4.1 Using index (subscript operator `[]`)
    *   6.1.4.2 Array indexing starts from 0
    *   6.1.4.3 Off-by-one errors and array bounds checking (C does not enforce it)
*   **6.1.5 Traversing Arrays**: Iterating through elements using loops.
    *   6.1.5.1 `for` loop for array traversal
*   **6.1.6 Variable Length Arrays (VLAs)**: C99 feature.
    *   6.1.6.1 Declaring array with size determined at runtime
    *   6.1.6.2 Scope and lifetime of VLAs
    *   6.1.6.3 Compatibility and potential issues (e.g., stack space)
6.2 Two-dimensional Arrays (Matrices)
code
Code
*   **6.2.1 What are 2D Arrays?**: Arrays of arrays.
    *   6.2.1.1 Representing matrices, tables
    *   6.2.1.2 Stored in row-major order in memory
*   **6.2.2 Declaration of Two-dimensional Arrays**:
    *   6.2.2.1 Syntax: `data_type array_name[rows][columns];`
*   **6.2.3 Initialization of Two-dimensional Arrays**:
    *   6.2.3.1 Row by row (e.g., `{{1,2}, {3,4}}`)
    *   6.2.3.2 Partial initialization
    *   6.2.3.3 Omitting row size (but column size is mandatory)
*   **6.2.4 Accessing Elements**:
    *   6.2.4.1 `array[row_index][col_index]`
*   **6.2.5 Traversing 2D Arrays**: Nested loops for rows and columns.
    *   6.2.5.1 Row-major traversal
    *   6.2.5.2 Column-major traversal
6.3 Multi-dimensional Arrays
code
Code
*   **6.3.1 Beyond 2D**: Arrays with 3 or more dimensions.
    *   6.3.1.1 Syntax: `data_type array_name[dim1][dim2][dim3]...;`
    *   6.3.1.2 Memory representation
    *   6.3.1.3 Accessing elements and traversal
*   **6.3.2 Practical Use Cases**: Limited for higher dimensions, often for specific mathematical or image processing tasks.
6.4 Arrays and Functions
code
Code
*   **6.4.1 Passing One-dimensional Arrays to Functions**:
    *   6.4.1.1 Arrays are passed by reference (address of the first element)
    *   6.4.1.2 Function parameter as `data_type array_name[]` or `data_type *array_name`
    *   6.4.1.3 Passing array size as a separate argument
*   **6.4.2 Passing Two-dimensional Arrays to Functions**:
    *   6.4.2.1 Column size must be specified in function parameter (e.g., `data_type array_name[][columns]`)
    *   6.4.2.2 Using pointers to pass 2D arrays (more complex, requires careful memory management or pointer arithmetic)
*   **6.4.3 Returning Arrays from Functions**:
    *   6.4.3.1 Cannot return an entire array by value
    *   6.4.3.2 Returning a pointer to the first element
    *   6.4.3.3 Dangers of returning pointers to local arrays (dangling pointers)
    *   6.4.3.4 Using dynamically allocated arrays or `static` arrays for return.
7. Strings
7.1 String Declaration and Initialization
code
Code
*   **7.1.1 What are Strings in C?**: Array of characters terminated by a null character (`\0`).
    *   7.1.1.1 `\0` is crucial for string functions to know the end.
*   **7.1.2 Declaring String Variables**:
    *   7.1.2.1 `char string_name[size];`
*   **7.1.3 Initializing Strings**:
    *   7.1.3.1 As a character array: `char str[] = {'H', 'e', 'l', 'l', 'o', '\0'};`
    *   7.1.3.2 As a string literal: `char str[] = "Hello";` (compiler adds `\0` automatically)
    *   7.1.3.3 Initializing with specific size: `char str[10] = "Hello";`
    *   7.1.3.4 Initializing a character pointer to a string literal: `char *str = "Hello";` (read-only string literal)
*   **7.1.4 String Literals**: Read-only data in memory.
    *   7.1.4.1 Stored in read-only data segment.
    *   7.1.4.2 Modifying string literals pointed to by `char *` results in undefined behavior.
7.2 String Input/Output
code
Code
*   **7.2.1 Reading Strings**:
    *   7.2.1.1 `scanf()` with `%s`: Reads until whitespace, dangerous without buffer size.
        *   7.2.1.1.1 Using `scanf("%9s", str);` to prevent buffer overflow (not completely safe).
    *   7.2.1.2 `gets()`: Reads entire line, highly unsafe, causes buffer overflow. **Avoid.**
    *   7.2.1.3 `fgets()`: Safer way to read a line from `stdin`.
        *   7.2.1.3.1 Syntax: `fgets(buffer, size, stdin)`
        *   7.2.1.3.2 Includes the newline character (`\n`) if it fits in the buffer.
*   **7.2.2 Writing Strings**:
    *   7.2.2.1 `printf()` with `%s`
    *   7.2.2.2 `puts()`: Prints string followed by a newline.
    *   7.2.2.3 `fputs()`: Prints string without adding newline (often used with `stdout`).
7.3 Standard String Functions (string.h)
code
Code
*   **7.3.1 Length of String**:
    *   7.3.1.1 `strlen(const char *str)`: Returns the number of characters before `\0`.
*   **7.3.2 Copying Strings**:
    *   7.3.2.1 `strcpy(char *dest, const char *src)`: Copies `src` to `dest`, including `\0`. **Unsafe, no bounds checking.**
    *   7.3.2.2 `strncpy(char *dest, const char *src, size_t n)`: Copies at most `n` characters. **Caution:** May not null-terminate if `src` is longer than `n`.
    *   7.3.2.3 `strlcpy()`: (Non-standard, safer alternative on some systems).
*   **7.3.3 Concatenating Strings**:
    *   7.3.3.1 `strcat(char *dest, const char *src)`: Appends `src` to `dest`. **Unsafe.**
    *   7.3.3.2 `strncat(char *dest, const char *src, size_t n)`: Appends at most `n` characters.
    *   7.3.3.3 `strlcat()`: (Non-standard, safer alternative).
*   **7.3.4 Comparing Strings**:
    *   7.3.4.1 `strcmp(const char *str1, const char *str2)`: Lexicographical comparison, returns 0 if equal, <0 if `str1` < `str2`, >0 if `str1` > `str2`.
    *   7.3.4.2 `strncmp(const char *str1, const char *str2, size_t n)`: Compares at most `n` characters.
    *   7.3.4.3 `strcasecmp()` / `strncasecmp()`: (Non-standard) Case-insensitive comparison.
*   **7.3.5 Searching in Strings**:
    *   7.3.5.1 `strchr(const char *str, int c)`: Finds first occurrence of character `c`.
    *   7.3.5.2 `strrchr(const char *str, int c)`: Finds last occurrence of character `c`.
    *   7.3.5.3 `strstr(const char *haystack, const char *needle)`: Finds first occurrence of substring `needle`.
    *   7.3.5.4 `strpbrk(const char *str, const char *charset)`: Finds first occurrence of any character from `charset`.
    *   7.3.5.5 `strtok(char *str, const char *delim)`: Tokenizes a string. **Caution: Modifies the original string, not re-entrant.**
    *   7.3.5.6 `strtok_r()` / `strtok_s()`: (Re-entrant/safer versions).
*   **7.3.6 Other Useful String Functions**:
    *   7.3.6.1 `memset()`: Fill block of memory (useful for initializing character arrays).
    *   7.3.6.2 `memcpy()`: Copy block of memory.
    *   7.3.6.3 `memcmp()`: Compare blocks of memory.
7.4 Character Handling (ctype.h)
code
Code
*   **7.4.1 Character Classification**:
    *   7.4.1.1 `isalpha()`: Is alphabetic character?
    *   7.4.1.2 `isdigit()`: Is digit character?
    *   7.4.1.3 `isalnum()`: Is alphanumeric character?
    *   7.4.1.4 `islower()`, `isupper()`: Is lowercase/uppercase?
    *   7.4.1.5 `isspace()`: Is whitespace character?
    *   7.4.1.6 `ispunct()`: Is punctuation character?
    *   7.4.1.7 `isprint()`: Is printable character?
    *   7.4.1.8 `isxdigit()`: Is hexadecimal digit character?
*   **7.4.2 Character Conversion**:
    *   7.4.2.1 `tolower()`: Convert to lowercase.
    *   7.4.2.2 `toupper()`: Convert to uppercase.
8. Pointers
8.1 Pointer Declaration and Initialization
code
Code
*   **8.1.1 What are Pointers?**: Variables that store memory addresses.
    *   8.1.1.1 Direct vs. indirect memory access
    *   8.1.1.2 Pointers hold addresses, not values
*   **8.1.2 Declaration of Pointers**:
    *   8.1.2.1 Syntax: `data_type *pointer_name;`
    *   8.1.2.2 The asterisk `*` signifies a pointer declaration.
    *   8.1.2.3 `data_type` indicates the type of data the pointer "points to".
*   **8.1.3 Initialization of Pointers**:
    *   8.1.3.1 Assigning an address (`&` operator): `int *ptr = &myVar;`
    *   8.1.3.2 `NULL` pointer: A pointer that points to no valid memory location.
        *   8.1.3.2.1 Macro `NULL` (from `stddef.h` or `stdlib.h`)
        *   8.1.3.2.2 `0` can also be used, but `NULL` is clearer.
        *   8.1.3.2.3 `nullptr` (C23 standard, previously C++ concept)
    *   8.1.3.3 Uninitialized pointers (wild pointers): dangerous, point to arbitrary memory.
*   **8.1.4 Dereferencing Pointers**: Accessing the value at the address stored in a pointer.
    *   8.1.4.1 Using the dereference operator `*`: `*ptr = 10;`
8.2 Pointer Arithmetic
code
Code
*   **8.2.1 Adding an Integer to a Pointer**: `ptr + n` moves `n * sizeof(data_type)` bytes.
*   **8.2.2 Subtracting an Integer from a Pointer**: `ptr - n`
*   **8.2.3 Subtracting Two Pointers**: `ptr2 - ptr1` (result is number of elements between them, only valid for pointers within the same array).
*   **8.2.4 Incrementing/Decrementing Pointers**: `ptr++`, `ptr--` (moves to next/previous element of pointed type).
*   **8.2.5 Comparison of Pointers**: `ptr1 == ptr2`, `ptr1 < ptr2`, etc. (valid only within the same array or `NULL`).
*   **8.2.6 Invalid Pointer Arithmetic**: Operations like `ptr1 + ptr2`, `ptr1 * ptr2` are illegal.
8.3 Pointers and Arrays
code
Code
*   **8.3.1 Array Name as a Pointer**: Array name often decays to a pointer to its first element.
    *   8.3.1.1 `array_name` is equivalent to `&array_name[0]` in many contexts.
*   **8.3.2 Accessing Array Elements using Pointers**:
    *   8.3.2.1 `*(array_name + i)` is equivalent to `array_name[i]`
    *   8.3.2.2 `i[array_name]` is also valid but unconventional
*   **8.3.3 Pointers to Multidimensional Arrays**:
    *   8.3.3.1 Pointer to an array (e.g., `int (*ptr)[columns];`)
    *   8.3.3.2 Array of pointers (e.g., `int *ptr[rows];`)
    *   8.3.3.3 Accessing elements using pointer arithmetic
*   **8.3.4 Pointer to an Array vs. Array of Pointers**: Understanding the memory layout.
8.4 Pointers and Functions
code
Code
*   **8.4.1 Passing Pointers to Functions**: Implementing call by reference.
    *   8.4.1.1 Modifying variables in the calling function
    *   8.4.1.2 Passing arrays to functions (as discussed in Arrays section)
*   **8.4.2 Returning Pointers from Functions**:
    *   8.4.2.1 Returning a pointer to dynamically allocated memory.
    *   8.4.2.2 **Danger of returning pointers to local variables** (dangling pointers).
*   **8.4.3 Pointers to Functions**: Storing function addresses.
    *   8.4.3.1 Declaration: `return_type (*pointer_name)(parameter_list);`
    *   8.4.3.2 Initialization: `pointer_name = &function_name;` or `pointer_name = function_name;`
    *   8.4.3.3 Invocation: `(*pointer_name)(arguments);` or `pointer_name(arguments);`
    *   8.4.3.4 Use cases: Callbacks, implementing polymorphic behavior, jump tables.
*   **8.4.4 Array of Function Pointers**: For implementing dispatch tables.
8.5 Pointers to Pointers (Double Pointers)
code
Code
*   **8.5.1 Declaration**: `data_type **ptr_to_ptr;`
*   **8.5.2 Usage**: Storing the address of another pointer.
*   **8.5.3 Dereferencing**: `**ptr_to_ptr` to access the final value.
*   **8.5.4 Common Use Cases**:
    *   8.5.4.1 Passing a pointer by reference to a function (e.g., modifying `head` of a linked list).
    *   8.5.4.2 Working with arrays of strings (`char *argv[]` in `main()`).
    *   8.5.4.3 Dynamic 2D arrays.
8.6 Pointers and Strings
code
Code
*   **8.6.1 String Literals and Pointers**: `char *str = "Hello";`
    *   8.6.1.1 `str` points to the first character of the string literal.
    *   8.6.1.2 The string literal itself is often read-only.
*   **8.6.2 Character Arrays vs. Character Pointers for Strings**:
    *   8.6.2.1 `char arr[] = "Hello";` (modificable array on stack)
    *   8.6.2.2 `char *ptr = "Hello";` (pointer to a read-only string literal)
    *   8.6.2.3 Differences in memory allocation and mutability.
*   **8.6.3 Dynamic String Allocation**: Using `malloc` to create modifiable strings.
*   **8.6.4 Array of String Pointers**: `char *names[] = {"Alice", "Bob"};`
8.7 Dynamic Memory Allocation (stdlib.h)
code
Code
*   **8.7.1 Heap vs. Stack Memory**: Understanding different memory regions.
    *   8.7.1.1 Stack: for local variables, function calls (automatic allocation).
    *   8.7.1.2 Heap: for dynamic allocation, programmer-managed.
*   **8.7.2 `malloc()`**: Allocates a block of memory of a specified size.
    *   8.7.2.1 Syntax: `void *malloc(size_t size);`
    *   8.7.2.2 Returns `void *` (generic pointer), requires type casting.
    *   8.7.2.3 Returns `NULL` on failure.
    *   8.7.2.4 Initializes allocated memory with garbage values.
*   **8.7.3 `calloc()`**: Allocates a block of memory for an array of elements and initializes them to zero.
    *   8.7.3.1 Syntax: `void *calloc(size_t num, size_t size);`
    *   8.7.3.2 Returns `void *`, `NULL` on failure.
    *   8.7.3.3 Zero-initializes the memory.
*   **8.7.4 `realloc()`**: Resizes an already allocated block of memory.
    *   8.7.4.1 Syntax: `void *realloc(void *ptr, size_t size);`
    *   8.7.4.2 Can move the memory block to a new location if current space is insufficient.
    *   8.7.4.3 Returns `NULL` on failure, original pointer remains valid.
    *   8.7.4.4 Can be used to free memory (`realloc(ptr, 0)`).
*   **8.7.5 `free()`**: Deallocates memory previously allocated by `malloc`, `calloc`, or `realloc`.
    *   8.7.5.1 Syntax: `void free(void *ptr);`
    *   8.7.5.2 Releasing memory back to the heap.
    *   8.7.5.3 **Memory Leaks**: Forgetting to `free` allocated memory.
    *   8.7.5.4 **Dangling Pointers**: Accessing memory after it has been freed.
    *   8.7.5.5 Double freeing memory (undefined behavior).
    *   8.7.5.6 Setting pointer to `NULL` after freeing.
*   **8.7.6 Using Dynamic Memory for Arrays**:
    *   8.7.6.1 Dynamic 1D arrays: `int *arr = (int *)malloc(N * sizeof(int));`
    *   8.7.6.2 Dynamic 2D arrays (array of pointers):
        *   Allocating row pointers: `int **matrix = (int **)malloc(rows * sizeof(int *));`
        *   Allocating columns for each row: `matrix[i] = (int *)malloc(cols * sizeof(int));`
    *   8.7.6.3 Freeing dynamic 2D arrays (in reverse order of allocation).
9. Structures and Unions
9.1 Structure Definition and Declaration
code
Code
*   **9.1.1 What are Structures?**: User-defined data types that group related data items (of potentially different types) under a single name.
    *   9.1.1.1 Heterogeneous data grouping
    *   9.1.1.2 Data members are stored in contiguous memory (subject to padding).
*   **9.1.2 Defining a Structure**:
    *   9.1.2.1 Syntax: `struct TagName { data_type member1; data_type member2; ... };`
    *   9.1.2.2 `TagName` is optional (anonymous structures).
*   **9.1.3 Declaring Structure Variables**:
    *   9.1.3.1 `struct TagName variable_name;`
    *   9.1.3.2 Declaring at definition: `struct TagName { ... } var1, var2;`
*   **9.1.4 Initialization of Structure Variables**:
    *   9.1.4.1 Member-wise initialization: `struct Point p = {10, 20};`
    *   9.1.4.2 Designated initializers (C99): `struct Point p = {.y = 20, .x = 10};`
9.2 Accessing Structure Members
code
Code
*   **9.2.1 Dot Operator (`.`)**: Used with structure variables.
    *   9.2.1.1 `variable_name.member_name`
*   **9.2.2 Arrow Operator (`->`)**: Used with pointers to structures.
    *   9.2.2.1 `pointer_name->member_name` (equivalent to `(*pointer_name).member_name`)
9.3 Nested Structures
code
Code
*   **9.3.1 Structure within a Structure**: A member of a structure can be another structure.
    *   9.3.1.1 Example: `struct Student { int id; struct Date dob; };`
    *   9.3.1.2 Accessing nested members: `student.dob.day`
9.4 Array of Structures
code
Code
*   **9.4.1 Declaring an Array of Structures**: `struct TagName array_name[size];`
*   **9.4.2 Initializing an Array of Structures**: Using braces for each structure element.
*   **9.4.3 Accessing Elements**: `array_name[index].member_name`
9.5 Pointer to Structure
code
Code
*   **9.5.1 Declaring Pointer to Structure**: `struct TagName *ptr;`
*   **9.5.2 Initializing Pointer**: `ptr = &variable_name;`
*   **9.5.3 Dynamic Allocation of Structures**:
    *   9.5.3.1 `struct TagName *ptr = (struct TagName *)malloc(sizeof(struct TagName));`
    *   9.5.3.2 Allocating an array of structures dynamically.
    *   9.5.3.3 Freeing allocated structure memory.
*   **9.5.4 Passing Structures to Functions**:
    *   9.5.4.1 By Value: Copies the entire structure, inefficient for large structures.
    *   9.5.4.2 By Reference (using pointers): Efficient, allows modification.
*   **9.5.5 Returning Structures from Functions**:
    *   9.5.5.1 By Value: Returns a copy of the structure.
    *   9.5.5.2 By Pointer: Returns a pointer to a dynamically allocated or `static` structure.
9.6 Unions
code
Code
*   **9.6.1 What are Unions?**: User-defined data types that can hold members of different data types, but **only one member can hold a value at any given time**.
    *   9.6.1.1 All members share the same memory location.
    *   9.6.1.2 Size of union is equal to the size of its largest member.
*   **9.6.2 Defining a Union**:
    *   9.6.2.1 Syntax: `union TagName { data_type member1; data_type member2; ... };`
*   **9.6.3 Declaring and Initializing Union Variables**: Similar to structures.
*   **9.6.4 Accessing Union Members**: Using dot (`.`) and arrow (`->`) operators.
    *   9.6.4.1 Be careful: accessing a member that wasn't the last one written leads to undefined behavior.
*   **9.6.5 Use Cases for Unions**:
    *   9.6.5.1 Memory optimization when only one piece of data is needed at a time.
    *   9.6.5.2 Type punning (interpreting the same memory in different ways, requires careful use).
    *   9.6.5.3 `variant` types in C (often combined with an `enum` in a struct to track the active member).
9.7 Difference between Structure and Union
code
Code
*   **9.7.1 Memory Allocation**:
    *   Structures: Separate memory for each member.
    *   Unions: Shared memory for all members.
*   **9.7.2 Accessing Members**:
    *   Structures: All members can be accessed concurrently.
    *   Unions: Only the last assigned member's value is valid.
*   **9.7.3 Purpose**:
    *   Structures: Group related but distinct data.
    *   Unions: Save memory, represent alternative types in the same memory space.
*   **9.7.4 Example Comparison**: Illustrating how memory is used.
9.8 Structure Padding and Alignment
code
Code
*   **9.8.1 What is Padding?**: Compiler adds unused bytes between structure members or at the end for alignment.
    *   9.8.1.1 Why padding is needed (CPU memory access efficiency).
*   **9.8.2 `_Alignof` operator (C11)**: Get alignment requirement of a type.
*   **9.8.3 `_Alignas` specifier (C11)**: Specify alignment for a variable or struct member.
*   **9.8.4 Packing Structures**: Forcing no padding (compiler-specific, e.g., `__attribute__((packed))` in GCC/Clang, `#pragma pack` in MSVC).
    *   9.8.4.1 Trade-offs: smaller size vs. slower access.
    *   9.8.4.2 Potential for unaligned access errors on some architectures.
10. File Handling
10.1 Basics of File Handling
code
Code
*   **10.1.1 What is File Handling?**: Persistent storage of data.
*   **10.1.2 File Pointer (`FILE *`)**: A pointer to a structure that contains information about the file (e.g., buffer address, current position).
    *   10.1.2.1 Declaring a file pointer: `FILE *fp;`
*   **10.1.3 Standard I/O Streams (`stdin`, `stdout`, `stderr`)**: File pointers implicitly available.
10.2 File Operations
code
Code
*   **10.2.1 `fopen()`**: Opens a file.
    *   10.2.1.1 Syntax: `FILE *fopen(const char *filename, const char *mode);`
    *   10.2.1.2 Returns `NULL` on failure.
    *   10.2.1.3 Importance of checking return value.
*   **10.2.2 `fclose()`**: Closes an opened file.
    *   10.2.2.1 Syntax: `int fclose(FILE *fp);`
    *   10.2.2.2 Releases resources, flushes buffers.
    *   10.2.2.3 Importance of closing files.
10.3 File Modes
code
Code
*   **10.3.1 Text Modes**: For human-readable text files.
    *   10.3.1.1 `"r"`: Read mode (file must exist).
    *   10.3.1.2 `"w"`: Write mode (creates new file, overwrites existing).
    *   10.3.1.3 `"a"`: Append mode (creates new file, appends to existing).
    *   10.3.1.4 `"r+"`: Read and write (file must exist).
    *   10.3.1.5 `"w+"`: Read and write (creates new file, overwrites).
    *   10.3.1.6 `"a+"`: Read and append (creates new file, appends).
*   **10.3.2 Binary Modes**: For raw byte data (images, executables).
    *   10.3.2.1 Add `"b"` suffix (e.g., `"rb"`, `"wb"`, `"ab+"`)
    *   10.3.2.2 Difference in newline character handling between text and binary modes (platform-dependent).
10.4 Formatted I/O (Text Files)
code
Code
*   **10.4.1 `fprintf()`**: Writes formatted data to a file.
    *   10.4.1.1 Syntax: `int fprintf(FILE *fp, const char *format, ...);`
    *   10.4.1.2 Similar to `printf`, but writes to a specified file.
*   **10.4.2 `fscanf()`**: Reads formatted data from a file.
    *   100.4.2.1 Syntax: `int fscanf(FILE *fp, const char *format, ...);`
    *   10.4.2.2 Similar to `scanf`, but reads from a specified file.
10.5 Character I/O (Text Files)
code
Code
*   **10.5.1 `fputc()`**: Writes a single character to a file.
    *   10.5.1.1 Syntax: `int fputc(int char_to_write, FILE *fp);`
*   **10.5.2 `fgetc()`**: Reads a single character from a file.
    *   10.5.2.1 Syntax: `int fgetc(FILE *fp);`
    *   10.5.2.2 Returns `EOF` (End-Of-File) on error or end of file.
10.6 String I/O (Text Files)
code
Code
*   **10.6.1 `fputs()`**: Writes a string to a file.
    *   10.6.1.1 Syntax: `int fputs(const char *str, FILE *fp);`
    *   10.6.1.2 Does not add a newline automatically.
*   **10.6.2 `fgets()`**: Reads a string (line) from a file.
    *   10.6.2.1 Syntax: `char *fgets(char *buffer, int size, FILE *fp);`
    *   10.6.2.2 Reads up to `size-1` characters or until newline, includes newline if present.
    *   10.6.2.3 Returns `NULL` on error or end of file.
10.7 Block I/O (Binary Files)
code
Code
*   **10.7.1 `fwrite()`**: Writes a block of data to a binary file.
    *   10.7.1.1 Syntax: `size_t fwrite(const void *ptr, size_t size, size_t count, FILE *fp);`
    *   10.7.1.2 Writes `count` items, each of `size` bytes, from `ptr`.
*   **10.7.2 `fread()`**: Reads a block of data from a binary file.
    *   10.7.2.1 Syntax: `size_t fread(void *ptr, size_t size, size_t count, FILE *fp);`
    *   10.7.2.2 Reads `count` items, each of `size` bytes, into `ptr`.
    *   10.7.2.3 Return value indicates number of items successfully read.
10.8 Random Access File I/O
code
Code
*   **10.8.1 `fseek()`**: Sets the file position indicator.
    *   10.8.1.1 Syntax: `int fseek(FILE *fp, long offset, int origin);`
    *   10.8.1.2 `origin`: `SEEK_SET` (beginning), `SEEK_CUR` (current), `SEEK_END` (end).
*   **10.8.2 `ftell()`**: Gets the current file position indicator.
    *   10.8.2.1 Syntax: `long ftell(FILE *fp);`
*   **10.8.3 `rewind()`**: Sets the file position indicator to the beginning of the file.
    *   10.8.3.1 Syntax: `void rewind(FILE *fp);`
*   **10.8.4 `fgetpos()` and `fsetpos()` (C99)**: For more robust positioning, especially with large files.
10.9 Error Handling in File Operations
code
Code
*   **10.9.1 `ferror()`**: Checks for error indicator on a file stream.
*   **10.9.2 `feof()`**: Checks for end-of-file indicator on a file stream.
*   **10.9.3 `perror()`**: Prints a system error message to `stderr`.
*   **10.9.4 `strerror()`**: Returns a pointer to an error message string (`string.h`).
*   **10.9.5 `errno`**: Global variable to store error numbers (`errno.h`).
*   **10.9.6 `clearerr()`**: Clears end-of-file and error indicators for a stream.
10.10 Other File Management Functions
code
Code
*   **10.10.1 `remove()`**: Deletes a file.
*   **10.10.2 `rename()`**: Renames a file.
*   **10.10.3 `tmpfile()`**: Creates a temporary binary file.
*   **10.10.4 `tmpnam()`**: Generates a unique temporary filename.
11. Preprocessor Directives
11.1 What are Preprocessor Directives?
code
Code
*   **11.1.1 Role of the Preprocessor**: First phase of compilation, performs text substitutions and conditional compilation.
*   **11.1.2 Syntax**: Lines beginning with `#`.
11.2 Macros (#define)
code
Code
*   **11.2.1 Object-like Macros**: Simple text substitution.
    *   11.2.1.1 Defining constants: `#define PI 3.14159`
    *   11.2.1.2 Replaces text literally, no type checking.
    *   11.2.1.3 Dangers of side effects with complex expressions.
*   **11.2.2 Function-like Macros**: Macros that take arguments.
    *   11.2.2.1 Defining simple functions: `#define MAX(a, b) ((a) > (b) ? (a) : (b))`
    *   11.2.2.2 Importance of parentheses around arguments and the entire macro body.
    *   11.2.2.3 Dangers of side effects and repeated evaluation of arguments.
    *   11.2.2.4 Debugging macros (using `-E` compiler flag).
*   **11.2.3 `#undef`**: Undefines a macro.
    *   11.2.3.1 Preventing redefinition errors.
*   **11.2.4 Predefined Macros**: Provided by the compiler (e.g., `__FILE__`, `__LINE__`, `__DATE__`, `__TIME__`, `__STDC__`).
11.3 File Inclusion (#include)
code
Code
*   **11.3.1 Purpose**: Inserts the content of another file into the current one.
*   **11.3.2 `<filename>`**: For standard library headers (searches standard include paths).
*   **11.3.3 `"filename"`**: For user-defined headers (searches current directory first, then standard paths).
*   **11.3.4 Header Guards**: Preventing multiple inclusions of the same header file.
    *   11.3.4.1 `#ifndef`, `#define`, `#endif` pattern.
    *   11.3.4.2 `#pragma once` (non-standard but widely supported).
11.4 Conditional Compilation
code
Code
*   **11.4.1 `#ifdef` / `#ifndef` / `#endif`**:
    *   11.4.1.1 Compiles code block if a macro is defined/not defined.
    *   11.4.1.2 Usage for platform-specific code, debugging.
*   **11.4.2 `#if` / `#elif` / `#else` / `#endif`**:
    *   11.4.2.1 Evaluates a constant integer expression.
    *   11.4.2.2 `#if defined(MACRO)` or `#if !defined(MACRO)`
    *   11.4.2.3 Using `&&`, `||`, `!`, `()` in conditions.
*   **11.4.3 `#error`**: Generates a compilation error with a message.
    *   11.4.3.1 Useful for enforcing compiler options or preventing unsupported builds.
*   **11.4.4 `#warning`**: Generates a compilation warning with a message.
11.5 Other Directives
code
Code
*   **11.5.1 `#line`**: Sets the line number and filename for subsequent code.
    *   11.5.1.1 Used by code generators.
*   **11.5.2 `#pragma`**: Compiler-specific directives.
    *   11.5.2.1 `#pragma once`
    *   11.5.2.2 `#pragma GCC diagnostic`
    *   11.5.2.3 `#pragma pack`
*   **11.5.3 `#null` directive**: An empty directive (effectively a no-op).
12. Advanced Topics (Part 1)
12.1 Command-Line Arguments
code
Code
*   **12.1.1 `main()` with Arguments**:
    *   12.1.1.1 `int main(int argc, char *argv[])`
    *   12.1.1.2 `argc`: Argument count (number of command-line arguments).
    *   12.1.1.3 `argv`: Array of strings (character pointers) holding the arguments.
    *   12.1.1.4 `argv[0]` is typically the program name.
*   **12.1.2 Parsing Command-Line Arguments**:
    *   12.1.2.1 Iterating through `argv`.
    *   12.1.2.2 Converting string arguments to numbers (`atoi`, `atof`, `strtol`, `strtod`).
    *   12.1.2.3 Using `getopt()` (POSIX standard) for more complex option parsing.
12.2 Enumerations (enum)
code
Code
*   **12.2.1 What are Enumerations?**: User-defined data type that consists of named integer constants.
*   **12.2.2 Declaring an `enum`**:
    *   12.2.2.1 `enum Days { SUNDAY, MONDAY, TUESDAY };`
*   **12.2.3 Assigning Values**:
    *   12.2.3.1 Default values (0, 1, 2, ...).
    *   12.2.3.2 Explicitly assigning values: `enum States { OFF = 0, ON = 1 };`
    *   12.2.3.3 Mixed explicit and implicit assignment.
*   **12.2.4 Using `enum`**:
    *   12.2.4.1 As symbolic constants.
    *   12.2.4.2 Improving code readability.
    *   12.2.4.3 `enum` variables are typically stored as `int`.
*   **12.2.5 Scoped Enumerations (C23 `enum class` or `enum struct`)**: Enhancing type safety.
12.3 typedef
code
Code
*   **12.3.1 Purpose**: Creates an alias (synonym) for an existing data type.
*   **12.3.2 Syntax**: `typedef existing_type new_name;`
*   **12.3.3 Use Cases**:
    *   12.3.3.1 Creating aliases for primitive types (e.g., `typedef unsigned long long ULL;`).
    *   12.3.3.2 Simplifying complex declarations (e.g., function pointers).
    *   12.3.3.3 Making code more portable (e.g., `size_t`).
    *   12.3.3.4 Giving structures and unions friendlier names:
        *   `typedef struct { ... } MyStruct;` (avoids `struct` keyword with declaration)
        *   `typedef union { ... } MyUnion;`
*   **12.3.4 `typedef` vs. `#define`**:
    *   12.3.4.1 `typedef` handles type definitions, `#define` handles text substitution.
    *   12.3.4.2 `typedef` obeys scope rules, `#define` does not.
    *   12.3.4.3 `typedef` correctly handles pointers (e.g., `typedef int* IntPtr; IntPtr a, b;` vs. `#define IntPtr int* ; IntPtr a, b;`).
12.4 Bit Fields
code
Code
*   **12.4.1 Purpose**: Allow grouping of small, integer-type members into a single word, specifying the number of bits each member occupies.
    *   12.4.1.1 Memory optimization (e.g., for flags, hardware registers).
*   **12.4.2 Declaring Bit Fields within Structures/Unions**:
    *   12.4.2.1 `struct Flags { unsigned int flag1 : 1; unsigned int flag2 : 2; ... };`
    *   12.4.2.2 Unnamed bit fields for padding.
    *   12.4.2.3 Zero-length bit field to force alignment to next allocation unit.
*   **12.4.3 Accessing Bit Fields**: Just like regular members using dot/arrow operators.
*   **12.4.4 Limitations of Bit Fields**:
    *   12.4.4.1 Cannot take address of a bit field.
    *   12.4.4.2 Compiler-dependent storage order (endianness).
    *   12.4.4.3 Portability issues.
    *   12.4.4.4 Not suitable for `char` or `float` types.
12.5 Error Handling
code
Code
*   **12.5.1 `errno` (from `errno.h`)**: Global variable to store error numbers set by library functions.
    *   12.5.1.1 Importance of checking `errno` immediately after a failed library call.
    *   12.5.1.2 Thread-safety considerations (`thread_local` `errno`).
*   **12.5.2 `perror()` and `strerror()`**: Functions for translating `errno` into human-readable messages.
*   **12.5.3 Assertions (`assert.h`)**: `assert(expression);`
    *   12.5.3.1 Used for debugging, checks conditions that must be true.
    *   12.5.3.2 Terminates program if assertion fails.
    *   12.5.3.3 Removed in release builds by `#define NDEBUG`.
*   **12.5.4 Custom Error Handling**:
    *   12.5.4.1 Returning error codes from functions.
    *   12.5.4.2 Logging errors.
    *   12.5.4.3 Global error states.
12.6 Linked Lists (Basic Implementation)
code
Code
*   **12.6.1 Concept of Linked Lists**: Dynamic data structure where elements are linked using pointers.
    *   12.6.1.1 Nodes: data + pointer to next node.
    *   12.6.1.2 Head pointer.
*   **12.6.2 Defining a Node Structure**:
    *   12.6.2.1 `struct Node { int data; struct Node *next; };`
    *   12.6.2.2 Self-referential structures.
*   **12.6.3 Basic Operations**:
    *   12.6.3.1 **Creation**: Initializing an empty list, creating the first node.
    *   12.6.3.2 **Insertion**:
        *   12.6.3.2.1 At the beginning (prepends).
        *   12.6.3.2.2 At the end (appends).
        *   12.6.3.2.3 At a specific position.
        *   12.6.3.2.4 In a sorted list.
    *   12.6.3.3 **Deletion**:
        *   12.6.3.3.1 Deleting the first node.
        *   12.6.3.3.2 Deleting the last node.
        *   12.6.3.3.3 Deleting a node by value or position.
    *   12.6.3.4 **Traversal**: Iterating through the list to print or process nodes.
    *   12.6.3.5 **Searching**: Finding a specific node.
    *   12.6.3.6 **Memory Management**: Using `malloc` for new nodes, `free` for deleted nodes.
*   **12.6.4 Types of Linked Lists (Brief Introduction)**:
    *   12.6.4.1 Singly Linked List (covered above)
    *   12.6.4.2 Doubly Linked List (pointers to `next` and `prev` nodes)
    *   12.6.4.3 Circular Linked List (last node points to first)
13. Standard Library Functions (Detailed)
13.1 stdlib.h (General Utilities)
code
Code
*   **13.1.1 Memory Allocation**: (Already covered in Pointers section: `malloc`, `calloc`, `realloc`, `free`).
*   **13.1.2 String to Number Conversion**:
    *   13.1.2.1 `atoi(const char *str)`: ASCII to integer.
    *   13.1.2.2 `atol(const char *str)`: ASCII to long integer.
    *   13.1.2.3 `atoll(const char *str)` (C99): ASCII to long long integer.
    *   13.1.2.4 `atof(const char *str)`: ASCII to float (double).
    *   13.1.2.5 `strtol(const char *str, char **endptr, int base)`: String to long integer with base.
    *   13.1.2.6 `strtoll(const char *str, char **endptr, int base)` (C99): String to long long.
    *   13.1.2.7 `strtoul(const char *str, char **endptr, int base)`: String to unsigned long integer.
    *   13.1.2.8 `strtoull(const char *str, char **endptr, int base)` (C99): String to unsigned long long.
    *   13.1.2.9 `strtod(const char *str, char **endptr)`: String to double.
    *   13.1.2.10 `strtof(const char *str, char **endptr)` (C99): String to float.
    *   13.1.2.11 `strtold(const char *str, char **endptr)` (C99): String to long double.
*   **13.1.3 Random Number Generation**:
    *   13.1.3.1 `rand()`: Generates pseudo-random integer.
    *   13.1.3.2 `srand(unsigned int seed)`: Seeds the random number generator.
    *   13.1.3.3 Using `time(NULL)` for seed.
    *   13.1.3.4 Generating numbers within a range.
*   **13.1.4 Environment Control**:
    *   13.1.4.1 `exit(int status)`: Terminates program, returns status.
    *   13.1.4.2 `abort()`: Causes abnormal program termination.
    *   13.1.4.3 `atexit(void (*func)(void))`: Registers function to be called at program termination.
    *   13.1.4.4 `system(const char *command)`: Executes a system command.
    *   13.1.4.5 `getenv(const char *name)`: Gets value of an environment variable.
*   **13.1.5 Searching and Sorting**:
    *   13.1.5.1 `qsort(void *base, size_t num, size_t size, int (*compar)(const void *, const void *))`: Quicksort algorithm.
    *   13.1.5.2 `bsearch(const void *key, const void *base, size_t num, size_t size, int (*compar)(const void *, const void *))`: Binary search.
    *   13.1.5.3 Understanding the comparison function.
13.2 string.h (String Manipulation)
code
Code
*   (Already covered in Strings section: `strlen`, `strcpy`, `strncpy`, `strcat`, `strncat`, `strcmp`, `strncmp`, `strchr`, `strrchr`, `strstr`, `strpbrk`, `strtok`, `memset`, `memcpy`, `memmove`, `memcmp`).
*   **13.2.1 `memmove()`**: Copies a block of memory, handles overlapping memory regions safely.
*   **13.2.2 `strcspn()`**: Gets span of characters not in set.
*   **13.2.3 `strspn()`**: Gets span of characters in set.
13.3 math.h (Mathematical Functions)
code
Code
*   **13.3.1 Trigonometric Functions**: `sin`, `cos`, `tan`, `asin`, `acos`, `atan`, `atan2`.
*   **13.3.2 Hyperbolic Functions**: `sinh`, `cosh`, `tanh`, `asinh`, `acosh`, `atanh`.
*   **13.3.3 Exponential and Logarithmic Functions**: `exp`, `log`, `log10`, `pow`, `sqrt`, `cbrt`.
*   **13.3.4 Ceiling, Floor, Absolute Value**: `ceil`, `floor`, `fabs`, `fmod`.
*   **13.3.5 Rounding Functions (C99)**: `round`, `trunc`, `nearbyint`.
*   **13.3.6 Floating-point Classification (C99)**: `isnan`, `isinf`, `isnormal`, `isfinite`.
*   **13.3.7 Constants**: `M_PI`, `M_E` (often non-standard, defined in C99 if `_USE_MATH_DEFINES` is defined).
*   **13.3.8 Error Handling**: `errno` (EDOM, ERANGE), `math_errhandling`.
13.4 time.h (Date and Time Utilities)
code
Code
*   **13.4.1 Time Representation**:
    *   13.4.1.1 `time_t`: Arithmetic type capable of representing time.
    *   13.4.1.2 `struct tm`: Structure for calendar date and time.
*   **13.4.2 Time Functions**:
    *   13.4.2.1 `time(time_t *timer)`: Gets current calendar time.
    *   13.4.2.2 `difftime(time_t time1, time_t time0)`: Calculates difference between two times.
    *   13.4.2.3 `clock()`: Processor time used by the program.
*   **13.4.3 Conversion Functions**:
    *   13.4.3.1 `gmtime(const time_t *timer)`: Converts `time_t` to UTC `struct tm`.
    *   13.4.3.2 `localtime(const time_t *timer)`: Converts `time_t` to local `struct tm`.
    *   13.4.3.3 `mktime(struct tm *timeptr)`: Converts `struct tm` to `time_t`.
    *   13.4.3.4 `asctime(const struct tm *timeptr)`: Converts `struct tm` to string (e.g., "Mon Jan 01 00:00:00 2000\n").
    *   13.4.3.5 `ctime(const time_t *timer)`: Converts `time_t` to string.
    *   13.4.3.6 `strftime(char *s, size_t maxsize, const char *format, const struct tm *timeptr)`: Formats `struct tm` to custom string.
*   **13.4.4 Time Zones**: `TZ` environment variable, `tzset()`.
13.5 ctype.h (Character Type Functions)
code
Code
*   (Already covered in Strings section: `isalpha`, `isdigit`, `isalnum`, `islower`, `isupper`, `isspace`, `ispunct`, `isprint`, `isxdigit`, `tolower`, `toupper`).
13.6 limits.h and float.h (Limits of Data Types)
code
Code
*   **13.6.1 `limits.h`**: Defines macros for integer type limits.
    *   13.6.1.1 `CHAR_BIT`, `SCHAR_MIN`, `SCHAR_MAX`, `UCHAR_MAX`
    *   13.6.1.2 `SHRT_MIN`, `SHRT_MAX`, `USHRT_MAX`
    *   13.6.1.3 `INT_MIN`, `INT_MAX`, `UINT_MAX`
    *   13.6.1.4 `LONG_MIN`, `LONG_MAX`, `ULONG_MAX`
    *   13.6.1.5 `LLONG_MIN`, `LLONG_MAX`, `ULLONG_MAX` (C99)
*   **13.6.2 `float.h`**: Defines macros for floating-point type limits and characteristics.
    *   13.6.2.1 `FLT_RADIX`, `FLT_MANT_DIG`, `FLT_EPSILON`
    *   13.6.2.2 `FLT_MIN`, `FLT_MAX`, `DBL_MIN`, `DBL_MAX`, `LDBL_MIN`, `LDBL_MAX`
13.7 stddef.h (Common Definitions)
code
Code
*   **13.7.1 `size_t`**: Unsigned integer type returned by `sizeof`.
*   **13.7.2 `ptrdiff_t`**: Signed integer type for pointer differences.
*   **13.7.3 `NULL`**: Macro for null pointer constant.
*   **13.7.4 `offsetof(type, member)` (C99)**: Returns offset of a member within a struct.
13.8 stdbool.h (Boolean Type and Values)
code
Code
*   **13.8.1 `bool`**: Macro expanding to `_Bool`.
*   **13.8.2 `true`**: Macro expanding to `1`.
*   **13.8.3 `false`**: Macro expanding to `0`.
13.9 stdint.h (Integer Types with Specified Width - C99)
code
Code
*   **13.9.1 Fixed-width Integer Types**:
    *   13.9.1.1 `int8_t`, `int16_t`, `int32_t`, `int64_t`
    *   13.9.1.2 `uint8_t`, `uint16_t`, `uint32_t`, `uint64_t`
*   **13.9.2 Minimum-width Integer Types**:
    *   13.9.2.1 `int_least8_t`, `int_least16_t`, etc.
*   **13.9.3 Fastest Minimum-width Integer Types**:
    *   13.9.3.1 `int_fast8_t`, `int_fast16_t`, etc.
*   **13.9.4 Integer Types Capable of Holding Object Pointers**:
    *   13.9.4.1 `intptr_t`, `uintptr_t`
*   **13.9.5 Greatest-width Integer Types**:
    *   13.9.5.1 `intmax_t`, `uintmax_t`
13.10 stdarg.h (Variable Argument Lists - C99)
code
Code
*   **13.10.1 Purpose**: For functions that accept a variable number of arguments (e.g., `printf`).
*   **13.10.2 Macros**:
    *   13.10.2.1 `va_list`: Type to hold information about arguments.
    *   13.10.2.2 `va_start(va_list ap, paramN)`: Initializes `ap`.
    *   13.10.2.3 `va_arg(va_list ap, type)`: Retrieves next argument.
    *   13.10.2.4 `va_end(va_list ap)`: Cleans up.
    *   13.10.2.5 `va_copy(va_list dest, va_list src)` (C99).
*   **13.10.3 Example**: Implementing a simple `sum` function with variable arguments.
14. Data Structures (Beyond Linked Lists)
14.1 Stacks
code
Code
*   **14.1.1 Concept**: LIFO (Last In, First Out) data structure.
*   **14.1.2 Array-based Implementation**:
    *   14.1.2.1 Fixed size.
    *   14.1.2.2 `push`, `pop`, `peek`, `isEmpty`, `isFull` operations.
*   **14.1.3 Linked List-based Implementation**:
    *   14.1.3.1 Dynamic size.
    *   14.1.3.2 Operations using linked list functions.
*   **14.1.4 Applications**: Function call stack, expression evaluation, undo/redo.
14.2 Queues
code
Code
*   **14.2.1 Concept**: FIFO (First In, First Out) data structure.
*   **14.2.2 Array-based Implementation**:
    *   14.2.2.1 Linear queue (front/rear pointers).
    *   14.2.2.2 Circular queue (efficient use of array space).
    *   14.2.2.3 `enqueue`, `dequeue`, `front`, `isEmpty`, `isFull` operations.
*   **14.2.3 Linked List-based Implementation**:
    *   14.2.3.1 Dynamic size.
    *   14.2.3.2 Operations using linked list functions.
*   **14.2.4 Applications**: Task scheduling, buffering, breadth-first search.
14.3 Trees (Binary Trees)
code
Code
*   **14.3.1 Concept**: Hierarchical data structure.
    *   14.3.1.1 Root, nodes, leaves, edges.
    *   14.3.1.2 Parent, child, sibling relationships.
    *   14.3.1.3 Depth, height.
*   **14.3.2 Binary Tree Definition**: Each node has at most two children (left and right).
*   **14.3.3 Node Structure**: `struct Node { int data; struct Node *left; struct Node *right; };`
*   **14.3.4 Traversal Methods**:
    *   14.3.4.1 Inorder (Left-Root-Right)
    *   14.3.4.2 Preorder (Root-Left-Right)
    *   14.3.4.3 Postorder (Left-Right-Root)
*   **14.3.5 Binary Search Trees (BST)**:
    *   14.3.5.1 Properties: Left child < Root < Right child.
    *   14.3.5.2 Insertion, searching, deletion in BST.
*   **14.3.6 AVL Trees (Self-balancing BSTs - Concept)**.
*   **14.3.7 Applications**: File systems, database indexing, expression trees.
14.4 Graphs
code
Code
*   **14.4.1 Concept**: Collection of nodes (vertices) and connections (edges).
    *   14.4.1.1 Directed vs. Undirected.
    *   14.4.1.2 Weighted vs. Unweighted.
    *   14.4.1.3 Cycles.
*   **14.4.2 Representation**:
    *   14.4.2.1 Adjacency Matrix (2D array).
    *   14.4.2.2 Adjacency List (array of linked lists).
*   **14.4.3 Graph Traversal (Concept)**:
    *   14.4.3.1 Breadth-First Search (BFS).
    *   14.4.3.2 Depth-First Search (DFS).
*   **14.4.4 Applications**: Social networks, routing algorithms, network topology.
14.5 Hash Tables
code
Code
*   **14.5.1 Concept**: Data structure for efficient key-value pair storage and retrieval.
    *   14.5.1.1 Hash function: maps keys to array indices.
    *   14.5.1.2 Collisions: when different keys map to the same index.
*   **14.5.2 Collision Resolution**:
    *   14.5.2.1 Separate Chaining (using linked lists at each index).
    *   14.5.2.2 Open Addressing (linear probing, quadratic probing, double hashing).
*   **14.5.3 Implementation in C**: Using arrays of linked lists.
*   **14.5.4 Applications**: Symbol tables, caching, unique data storage.
15. Algorithms
15.1 Sorting Algorithms
code
Code
*   **15.1.1 Comparison-based Sorts**:
    *   15.1.1.1 **Bubble Sort**: Simple, inefficient for large lists.
    *   15.1.1.2 **Selection Sort**: Finds minimum/maximum, places it.
    *   15.1.1.3 **Insertion Sort**: Builds sorted list one element at a time.
    *   15.1.1.4 **Merge Sort**: Divide and conquer, stable, efficient `O(N log N)`.
    *   15.1.1.5 **Quick Sort**: Divide and conquer, in-place, efficient `O(N log N)` average, `O(N^2)` worst case.
        *   15.1.1.5.1 Partition schemes (Lomuto, Hoare).
    *   15.1.1.6 **Heap Sort**: Uses a binary heap, `O(N log N)`.
*   **15.1.2 Non-comparison-based Sorts**:
    *   15.1.2.1 **Counting Sort**: For integers within a specific range.
    *   15.1.2.2 **Radix Sort**: Sorts by digits, efficient for large numbers with fixed digit count.
    *   15.1.2.3 **Bucket Sort**: Distributes elements into buckets.
*   **15.1.3 Performance Analysis**: Time and space complexity (`O` notation).
*   **15.1.4 Stability of Sorting Algorithms**.
15.2 Searching Algorithms
code
Code
*   **15.2.1 Linear Search**:
    *   15.2.1.1 Sequential check, `O(N)`.
*   **15.2.2 Binary Search**:
    *   15.2.2.1 Requires sorted data, `O(log N)`.
    *   15.2.2.2 Iterative and recursive implementations.
*   **15.2.3 Hashing-based Search**: `O(1)` average case (with good hash function).
15.3 Graph Algorithms (Advanced Introduction)
code
Code
*   **15.3.1 Shortest Path Algorithms**:
    *   15.3.1.1 Dijkstra's Algorithm (single source, non-negative weights).
    *   15.3.1.2 Bellman-Ford Algorithm (single source, handles negative weights).
    *   15.3.1.3 Floyd-Warshall Algorithm (all pairs shortest path).
*   **15.3.2 Minimum Spanning Tree (MST)**:
    *   15.3.2.1 Prim's Algorithm.
    *   15.3.2.2 Kruskal's Algorithm.
*   **15.3.3 Topological Sort**: For directed acyclic graphs (DAGs).
15.4 Dynamic Programming (Concept)
code
Code
*   **15.4.1 Overlapping Subproblems**.
*   **15.4.2 Optimal Substructure**.
*   **15.4.3 Memoization vs. Tabulation**.
*   **15.4.4 Simple Examples**: Fibonacci sequence, knapsack problem (conceptual).
15.5 Recursion and Backtracking
code
Code
*   **15.5.1 Deep Dive into Recursive Thinking**.
*   **15.5.2 Backtracking**: Exploring all possible paths to find solutions.
    *   15.5.2.1 N-Queens problem.
    *   15.5.2.2 Sudoku solver.
    *   15.5.2.3 Permutations and combinations.
16. Advanced C Features
16.1 Qualifiers
code
Code
*   **16.1.1 `const` (Constant)**: (Already covered in Variables/Pointers, but in detail for functions).
    *   16.1.1.1 `const` with function parameters (input safety).
    *   16.1.1.2 `const` with return values.
*   **16.1.2 `volatile`**: Prevents compiler from optimizing away access to a variable.
    *   16.1.2.1 Used for memory-mapped I/O, shared memory in multi-threaded environments, signal handlers.
    *   16.1.2.2 Ensures variable is always read from/written to memory.
*   **16.1.3 `restrict` (C99)**: Hint to the compiler that a pointer is the sole means of accessing a memory block.
    *   16.1.3.1 Enables aggressive compiler optimizations.
    *   16.1.3.2 Misuse leads to undefined behavior.
16.2 Complex Numbers (complex.h - C99)
code
Code
*   **16.2.1 `float _Complex`, `double _Complex`, `long double _Complex`**: Complex number types.
*   **16.2.2 Macros**: `I` (imaginary unit), `creal`, `cimag`, `cabs`, `carg`, `conj`.
*   **16.2.3 Complex Arithmetic**: Addition, subtraction, multiplication, division.
16.3 Generic Programming (_Generic - C11)
code
Code
*   **16.3.1 Purpose**: Allows selecting a function or macro based on the type of an expression.
*   **16.3.2 Syntax**: `_Generic(expression, type: association, ...)`
*   **16.3.3 Use Cases**: Implementing type-generic functions (e.g., a `print_value` that works for different types).
16.4 Atomic Operations (stdatomic.h - C11)
code
Code
*   **16.4.1 Need for Atomicity**: In multi-threaded programming, ensures operations are indivisible.
*   **16.4.2 `_Atomic` type specifier**: Declares atomic variables.
*   **16.4.3 Atomic Operations**: `atomic_load`, `atomic_store`, `atomic_exchange`, `atomic_compare_exchange_weak`, `atomic_compare_exchange_strong`, `atomic_fetch_add`, etc.
*   **16.4.4 Memory Ordering**: `memory_order_relaxed`, `memory_order_consume`, `memory_order_acquire`, `memory_order_release`, `memory_order_acq_rel`, `memory_order_seq_cst`.
16.5 Threads (threads.h - C11)
code
Code
*   **16.5.1 Introduction to Concurrency**: Running multiple parts of a program simultaneously.
*   **16.5.2 `thrd_t`**: Thread identifier type.
*   **16.5.3 `thrd_create()`**: Creates a new thread.
*   **16.5.4 `thrd_join()`**: Waits for a thread to terminate.
*   **16.5.5 Mutexes (`mtx_t`, `mtx_lock`, `mtx_unlock`)**: For mutual exclusion, protecting shared resources.
*   **16.5.6 Condition Variables (`cnd_t`, `cnd_wait`, `cnd_signal`, `cnd_broadcast`)**: For thread synchronization.
*   **16.5.7 Thread-local Storage (`_Thread_local`)**: Variables private to each thread.
*   **16.5.8 `call_once()`**: Ensures a function is called only once.
*   **16.5.9 C11 Threads vs. POSIX Threads (pthreads)**: C11 offers a standard, `pthreads` is a widely used external library.
17. Memory Layout and Management
17.1 Program Memory Layout
code
Code
*   **17.1.1 Text Segment (`.text`)**: Code (instructions).
*   **17.1.2 Data Segment (`.data`, `.rodata`)**: Initialized global/static variables. Read-only data.
*   **17.1.3 BSS Segment (`.bss`)**: Uninitialized global/static variables (zeroed by loader).
*   **17.1.4 Heap**: Dynamically allocated memory (grows upwards).
*   **17.1.5 Stack**: Local variables, function call frames (grows downwards).
17.2 Memory Errors
code
Code
*   **17.2.1 Memory Leaks**: Forgetting to `free` dynamically allocated memory.
*   **17.2.2 Dangling Pointers**: Pointers that refer to memory that has been deallocated.
*   **17.2.3 Double Free**: Freeing the same memory twice.
*   **17.2.4 Buffer Overflow**: Writing past the end of an allocated buffer.
*   **17.2.5 Use After Free**: Accessing memory after it's been freed.
*   **17.2.6 Uninitialized Memory Access**: Reading from memory that hasn't been written to.
*   **17.2.7 Tools for Memory Debugging**: Valgrind, AddressSanitizer.
17.3 Advanced Memory Management Concepts
code
Code
*   **17.3.1 Memory Mapping (`mmap()` - POSIX)**: Mapping files or devices into memory.
*   **17.3.2 Custom Allocators**: Implementing your own `malloc`/`free` for specific needs (e.g., fixed-size blocks, arenas).
*   **17.3.3 Memory Pools**: Pre-allocating a large block and managing sub-allocations.
18. Build Systems and Project Management
18.1 Makefiles
code
Code
*   **18.1.1 Purpose**: Automate the build process of software projects.
*   **18.1.2 Basic Syntax**: `target: dependencies` followed by `[TAB] command`.
*   **18.1.3 Variables**: Defining and using variables.
*   **18.1.4 Rules**: Explicit and implicit rules.
*   **18.1.5 Phony Targets**: `.PHONY`.
*   **18.1.6 Standard Makefile Targets**: `all`, `clean`, `install`, `test`.
*   **18.1.7 Debugging Makefiles**.
18.2 Version Control (Git)
code
Code
*   **18.2.1 Basic Git Commands**: `init`, `clone`, `add`, `commit`, `status`, `diff`.
*   **18.2.2 Branching and Merging**: `branch`, `checkout`, `merge`.
*   **18.2.3 Remote Repositories**: `push`, `pull`, `fetch`.
*   **18.2.4 `.gitignore`**: Excluding files.
18.3 Debugging C Programs
code
Code
*   **18.3.1 Debugging Principles**: Reproduce, isolate, fix, verify.
*   **18.3.2 GDB (GNU Debugger)**:
    *   18.3.2.1 Compilation with `-g` flag.
    *   18.3.2.2 Setting breakpoints.
    *   18.3.2.3 Stepping through code (`next`, `step`).
    *   18.3.2.4 Examining variables (`print`).
    *   18.3.2.5 Call stack (`bt`).
*   **18.3.3 IDE Debuggers**: Visual Studio Code, Visual Studio, CLion.
*   **18.3.4 Printf Debugging**: Simple but effective.
18.4 Profiling and Performance Optimization
code
Code
*   **18.4.1 Profiling Tools**: `gprof`, `perf`.
*   **18.4.2 Identifying Bottlenecks**.
*   **18.4.3 Optimization Techniques**:
    *   18.4.3.1 Algorithm choice.
    *   18.4.3.2 Data structure choice.
    *   18.4.3.3 Cache locality.
    *   18.4.3.4 Loop unrolling.
    *   18.4.3.5 Function inlining.
    *   18.4.3.6 Compiler optimization flags (e.g., `-O1`, `-O2`, `-O3`, `-Os`).
19. Networking in C (Basic Socket Programming - POSIX)
19.1 Introduction to Network Programming
code
Code
*   **19.1.1 Client-Server Model**.
*   **19.1.2 TCP/IP Protocol Suite**.
*   **19.1.3 Sockets**: Endpoints for communication.
19.2 Socket Types
code
Code
*   **19.2.1 Stream Sockets (TCP)**: Reliable, ordered, connection-oriented.
*   **19.2.2 Datagram Sockets (UDP)**: Unreliable, unordered, connectionless.
19.3 Basic TCP Client-Server Communication
code
Code
*   **19.3.1 Server Side**:
    *   19.3.1.1 `socket()`: Create a socket.
    *   19.3.1.2 `bind()`: Associate socket with an address and port.
    *   19.3.1.3 `listen()`: Prepare for incoming connections.
    *   19.3.1.4 `accept()`: Accept a new connection (blocks).
    *   19.3.1.5 `send()`, `recv()`: Send/receive data.
    *   19.3.1.6 `close()`: Close the socket.
*   **19.3.2 Client Side**:
    *   19.3.2.1 `socket()`: Create a socket.
    *   19.3.2.2 `connect()`: Establish connection to server.
    *   19.3.2.3 `send()`, `recv()`: Send/receive data.
    *   19.3.2.4 `close()`: Close the socket.
*   **19.3.3 Address Structures**: `sockaddr_in`, `sockaddr_storage`.
*   **19.3.4 Host to Network Byte Order Conversion**: `htons`, `htonl`, `ntohs`, `ntohl`.
*   **19.3.5 IP Address Conversion**: `inet_pton`, `inet_ntop`.
19.4 Error Handling in Sockets
code
Code
*   **19.4.1 `errno` for Socket Functions**.
*   **19.4.2 `getsockopt()` / `setsockopt()`**: Socket options (e.g., `SO_REUSEADDR`).
20. Inter-Process Communication (IPC - POSIX)
20.1 Pipes
code
Code
*   **20.1.1 Unnamed Pipes**: For related processes (parent-child).
    *   20.1.1.1 `pipe()`: Creates a pipe.
    *   20.1.1.2 `fork()`: Creates a child process.
    *   20.1.1.3 `read()`, `write()`: Using pipe file descriptors.
*   **20.1.2 Named Pipes (FIFOs)**: For unrelated processes.
    *   20.1.2.1 `mkfifo()`: Creates a FIFO file.
    *   20.1.2.2 `open()`, `read()`, `write()`, `close()`.
20.2 Message Queues
code
Code
*   **20.2.1 Concept**: List of messages stored within the kernel.
*   **20.2.2 `msgget()`**: Creates or gets a message queue.
*   **20.2.3 `msgsnd()`**: Sends a message.
*   **20.2.4 `msgrcv()`**: Receives a message.
*   **20.2.5 `msgctl()`**: Controls message queue properties.
20.3 Shared Memory
code
Code
*   **20.3.1 Concept**: Multiple processes map the same region of physical memory into their address spaces.
*   **20.3.2 `shmget()`**: Creates or gets a shared memory segment.
*   **20.3.3 `shmat()`**: Attaches shared memory to process address space.
*   **20.3.4 `shmdt()`**: Detaches shared memory.
*   **20.3.5 `shmctl()`**: Controls shared memory properties.
*   **20.3.6 Synchronization**: Requires explicit synchronization mechanisms (e.g., semaphores) to avoid race conditions.
20.4 Semaphores
code
Code
*   **20.4.1 Concept**: Synchronization primitive to control access to shared resources.
*   **20.4.2 Binary Semaphores (Mutually Exclusive)**.
*   **20.4.3 Counting Semaphores**.
*   **20.4.4 `semget()`**: Creates or gets a semaphore set.
*   **20.4.5 `semop()`**: Performs operations on semaphores (P/V operations).
*   **20.4.6 `semctl()`**: Controls semaphore properties.
21. Advanced System Programming
21.1 Process Management
code
Code
*   **21.1.1 `fork()`**: Creates a new process (child process).
*   **21.1.2 `exec` family**: Replaces current process image with a new one (`execl`, `execv`, `execle`, `execve`, `execlp`, `execvp`).
*   **21.1.3 `wait()` / `waitpid()`**: Parent waits for child process to terminate.
*   **21.1.4 `getpid()` / `getppid()`**: Get process ID / parent process ID.
*   **21.1.5 `exit()` / `_exit()`**: Terminating processes.
*   **21.1.6 Zombie Processes and Orphan Processes**.
*   **21.1.7 Daemonization**: Detaching a process from controlling terminal.
21.2 Signal Handling
code
Code
*   **21.2.1 What are Signals?**: Software interruptions to a process.
*   **21.2.2 Common Signals**: `SIGINT`, `SIGTERM`, `SIGKILL`, `SIGSEGV`, `SIGFPE`.
*   **21.2.3 `signal()`**: Simple signal handler.
*   **21.2.4 `sigaction()`**: More robust signal handling (C99 and POSIX).
    *   21.2.4.1 Handling re-entrant functions.
    *   21.2.4.2 Signal masks.
*   **21.2.5 `kill()`**: Sends a signal to a process.
*   **21.2.6 `raise()`**: Sends a signal to the calling process.
21.3 Terminal I/O
code
Code
*   **21.3.1 `termios.h`**: Controlling terminal attributes.
    *   21.3.1.1 Raw mode vs. canonical mode.
    *   21.3.1.2 Reading single characters without Enter.
*   **21.3.2 Non-blocking I/O (`fcntl.h`)**.
22. C Standard Library (clc) Further Exploration
22.1 iso646.h (Alternative Operator Spellings - C99)
code
Code
*   **22.1.1 Macros**: `and`, `or`, `not`, `xor`, `bitand`, `bitor`, `compl`, `and_eq`, `or_eq`, `xor_eq`, `not_eq`.
*   **22.1.2 Purpose**: For keyboards lacking standard C symbols.
22.2 wctype.h and wchar.h (Wide Characters and Strings - C99)
code
Code
*   **22.2.1 `wchar_t`**: Wide character type.
*   **22.2.2 `wint_t`**: Integer type capable of holding `wchar_t` and `WEOF`.
*   **22.2.3 Functions**: `wprintf`, `wscanf`, `wcslen`, `wcscpy`, `iswalpha`, `towlower`, etc.
*   **22.2.4 Multibyte Character Handling**: `mblen`, `mbtowc`, `wctomb`.
*   **22.2.5 Locale**: `setlocale()` for language-specific behavior.
22.3 fenv.h (Floating-Point Environment - C99)
code
Code
*   **22.3.1 Purpose**: Accessing and controlling floating-point status flags and control modes.
*   **22.3.2 Functions**: `feclearexcept`, `fetestexcept`, `feraiseexcept`, `fegetround`, `fesetround`.
*   **22.3.3 Floating-Point Exceptions**: Divide-by-zero, invalid operation, overflow, underflow, inexact.
22.4 inttypes.h (Integer Formatted I/O - C99)
code
Code
*   **22.4.1 Macros for `printf`/`scanf` formats**:
    *   22.4.1.1 `PRIx64`, `PRId32`, `SCNu16`, etc.
*   **22.4.2 Useful for fixed-width integer types**.
22.5 tgmath.h (Type-Generic Math - C99)
code
Code
*   **22.5.1 Purpose**: Macros that expand to `math.h` functions based on argument type.
*   **22.5.2 Example**: `sqrt(x)` can become `sqrtf(x)` if `x` is `float`, `sqrt(x)` if `x` is `double`, etc.
23. Best Practices and Code Quality
23.1 Coding Standards
code
Code
*   **23.1.1 Readability**: Consistent indentation, meaningful variable names, clear comments.
*   **23.1.2 Portability**: Avoiding platform-specific code where possible.
*   **23.1.3 Robustness**: Error checking, handling edge cases.
*   **23.1.4 Maintainability**: Modular design, clear interfaces.
*   **23.1.5 Common Standards**: MISRA C, CERT C, Google C++ Style Guide (relevant parts for C).
23.2 Modularity and Abstraction
code
Code
*   **23.2.1 Header Files (`.h`)**:
    *   23.2.1.1 Declarations only.
    *   23.2.1.2 Public interface.
    *   23.2.1.3 Header guards.
*   **23.2.2 Source Files (`.c`)**:
    *   23.2.2.1 Definitions and implementations.
    *   23.2.2.2 Private implementation details (`static`).
*   **23.2.3 Separation of Concerns**.
23.3 Testing
code
Code
*   **23.3.1 Unit Testing**: Testing individual functions/modules.
*   **23.3.2 Integration Testing**: Testing interaction between modules.
*   **23.3.3 Test Frameworks (e.g., Unity, Check, CppUnit)**.
*   **23.3.4 Test-Driven Development (TDD) principles**.
23.4 Security Considerations in C
code
Code
*   **23.4.1 Buffer Overflows**: Using safe string/buffer functions (`strncpy`, `snprintf`, `fgets`).
*   **23.4.2 Format String Vulnerabilities**: Never use user input directly in `printf` format string.
*   **23.4.3 Integer Overflows/Underflows**.
*   **23.4.4 Race Conditions**: Proper synchronization in concurrent code.
*   **23.4.5 Input Validation**.
24. C Language Miscellany and Deeper Dives
24.1 Undefined Behavior and Unspecified Behavior
code
Code
*   **24.1.1 What is UB?**: Behavior that is not specified by the C standard.
    *   24.1.1.1 Can lead to crashes, incorrect results, or seemingly benign behavior that changes with compiler/platform.
*   **24.1.2 Common UB Examples**:
    *   24.1.2.1 Dereferencing null or wild pointers.
    *   24.1.2.2 Out-of-bounds array access.
    *   24.1.2.3 Modifying string literals.
    *   24.1.2.4 Division by zero.
    *   24.1.2.5 Sequence point issues (e.g., `i = i++ + i++;`).
    *   24.1.2.6 Signed integer overflow.
*   **24.1.3 The Importance of Avoiding UB**.
24.2 Linkage (Internal, External, None)
code
Code
*   **24.2.1 External Linkage**: Visible across multiple translation units (default for global variables/functions).
*   **24.2.2 Internal Linkage**: Visible only within the current translation unit (`static` global variables/functions).
*   **24.2.3 No Linkage**: Visible only within its scope (local variables, parameters).
24.3 Translation Units
code
Code
*   **24.3.1 What is a Translation Unit?**: A single `.c` file after preprocessing, plus all included headers.
*   **24.3.2 Relationship to Linking**.
24.4 Data Alignment (Revisit)
code
Code
*   **24.4.1 Detailed Explanation of Processor Alignment Requirements**.
*   **24.4.2 Impact on Performance and Portability**.
24.5 Variadic Macros (C99)
code
Code
*   **24.5.1 Syntax**: `#define LOG(...) printf(__VA_ARGS__)`
*   **24.5.2 Using `##__VA_ARGS__` to handle empty arguments**.
*   **24.5.3 Use cases**: Flexible logging functions.
24.6 Inline Functions (C99 inline keyword)
code
Code
*   **24.6.1 Purpose**: Suggest to compiler to replace function call with function body at call site.
*   **24.6.2 Linkage and Definition Rules for `inline`**: Complex interactions, often best used with `static inline` or specific GCC extensions.
*   **24.6.3 `extern inline`**.
24.7 Common C Idioms and Design Patterns (Brief)
code
Code
*   **24.7.1 Opaque Pointers**: Hiding structure details from users.
*   **24.7.2 Abstract Data Types (ADT)**: Defining an interface for data structures.
*   **24.7.3 State Machines**: Implementing state-based logic.
*   **24.7.4 Callback Functions**: Using function pointers for events.
24.8 Embedded C Programming (Brief Overview)
code
Code
*   **24.8.1 Constraints**: Limited memory, CPU, no OS.
*   **24.8.2 Register Access**: Direct manipulation of hardware registers.
*   **24.8.3 Volatile keyword importance**.
*   **24.8.4 Fixed-point arithmetic**.
*   **24.8.5 Toolchains**: Cross-compilers, debuggers.
25. C23 (C17/C18) and Future C Standards
25.1 Review of C11 and C17/C18 Features (Summary)
code
Code
*   **25.1.1 C11**: Threads, atomics, generic selections, `_Noreturn`, `_Static_assert`, anonymous structs/unions.
*   **25.1.2 C17/C18**: Minor corrections, no major new features.
25.2 Key Features Proposed/Adopted for C23
code
Code
*   **25.2.1 `bool`, `true`, `false` as keywords**: No longer need `stdbool.h`.
*   **25.2.2 `static_assert` as keyword**: No longer need `_Static_assert`.
*   **25.2.3 `nullptr_t` and `nullptr`**: A standard null pointer constant.
*   **25.2.4 `typeof` / `typeof_unqual`**: Getting the type of an expression.
*   **25.2.5 Attributes (`[[attr]]`)**: Standard way to provide compiler hints.
    *   25.2.5.1 `[[noreturn]]`, `[[fallthrough]]`, `[[maybe_unused]]`, `[[nodiscard]]`.
*   **25.2.6 Decimal Floating-Point Types (`_Decimal32`, `_Decimal64`, `_Decimal128`)**: For financial and exact calculations.
*   **25.2.7 Binary Literals (`0b` prefix)**.
*   **25.2.8 Digit Separators (`'`)**: `1'000'000`.
*   **25.2.9 New String Literals**: UTF-8 (`u8`), UTF-16 (`u`), UTF-32 (`U`).
*   **25.2.10 Empty Initializer Braces `{}`**: For aggregate types.
*   **25.2.11 Improvements to `char`**: Guaranteed to be signed or unsigned.
*   **25.2.12 Relaxed `restrict` usage**.
*   **25.2.13 Bit-precise integer types**: `_BitInt(N)`.
*   **25.2.14 Type-generic macros for `fabs`, `sqrt`, etc.**
This roadmap provides a truly comprehensive overview, covering over 1000 distinct topics by drilling down into sub-sub-topics within each major category. It should serve as an excellent guide for mastering C programming.
Here's an illustrative image representing the vastness and interconnectedness of C programming concepts, a "roadmap" visualized.